C51 COMPILER V9.60.0.0   IO                                                                12/23/2019 14:27:43 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE IO
OBJECT MODULE PLACED IN .\Objects\io.obj
COMPILER INVOKED BY: C:\Users\M\AppData\Local\Keil\Keil_v4\C51\BIN\C51.EXE ..\lib\user\src\io.c LARGE OPTIMIZE(8,SPEED) 
                    -BROWSE INCDIR(..\lib\n76e003\Include;..\lib\user\inc) DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\Listings\io.lst) TA
                    -BS(2) OBJECT(.\Objects\io.obj)

line level    source

   1          #include "io.h"
   2          
   3          Struct_IOData ioData = {0};
   4          
   5          ///////////////////////////////////////////////LED//////////////////////////////////////////////////////
   6          
   7          void ledEnable(unsigned char ch)
   8          {
   9   1        LED_DISEN0; LED_DISEN1; LED_DISEN2; LED_DISEN3;
  10   1        
  11   1        switch(ch)
  12   1        {
  13   2          case 0: LED_ALL_OFF; LED_EN0; break;
  14   2          case 1: LED_ALL_OFF; LED_EN1; break;
  15   2          case 2: LED_ALL_OFF; LED_EN2; break;
  16   2          case 3: LED_ALL_OFF; LED_EN3; break;
  17   2          case 4: LED_ALL_EN; break;
  18   2          case 5: LED_ALL_DISEN; break;
  19   2        }
  20   1      }
  21          
  22          void dispalyNumber(unsigned char num)
  23          {
  24   1        switch(num)
  25   1        {
  26   2          case 0: LED_SHOW_NUM0; break;
  27   2          case 1: LED_SHOW_NUM1; break;
  28   2          case 2: LED_SHOW_NUM2; break;
  29   2          case 3: LED_SHOW_NUM3; break;
  30   2          case 4: LED_SHOW_NUM4; break;
  31   2          case 5: LED_SHOW_NUM5; break;
  32   2          case 6: LED_SHOW_NUM6; break;
  33   2          case 7: LED_SHOW_NUM7; break;
  34   2          case 8: LED_SHOW_NUM8; break;
  35   2          case 9: LED_SHOW_NUM9; break;
  36   2          case 10: LED_SHOW_NUM10; break;
  37   2          case 11: LED_SHOW_NUM11; break;
  38   2          case 12: LED_SHOW_NUM12; break;
  39   2          case 13: LED_SHOW_NUM13; break;
  40   2          case 14: LED_SHOW_NUM14; break;
  41   2          case 15: LED_SHOW_NUM15; break;
  42   2          case 16: LED_SHOW_NUM16; break;
  43   2          case 17: LED_SHOW_NUM17; break;
  44   2          case 18: LED_SHOW_NUM18; break;
  45   2          case 19: LED_SHOW_NUM19; break;
  46   2          case 30: LED_SHOW_NUM30; break;
  47   2          case 98: LED_ALL_ON; break;
  48   2          case 99: LED_ALL_OFF; break;
  49   2          default: LED_ALL_ON; break;
  50   2        }
  51   1      }
  52          
  53          void setLed(unsigned char ch)
C51 COMPILER V9.60.0.0   IO                                                                12/23/2019 14:27:43 PAGE 2   

  54          {
  55   1        switch(ch)
  56   1        {
  57   2          case 0: LED_A_ON; break;
  58   2          case 1: LED_B_ON; break;
  59   2          case 2: LED_C_ON; break;
  60   2          case 3: LED_D_ON; break;
  61   2          case 4: LED_E_ON; break;
  62   2        }
  63   1      }
  64          
  65          void resetLed(unsigned char ch)
  66          {
  67   1        switch(ch)
  68   1        {
  69   2          case 0: LED_A_OFF; break;
  70   2          case 1: LED_B_OFF; break;
  71   2          case 2: LED_C_OFF; break;
  72   2          case 3: LED_D_OFF; break;
  73   2          case 4: LED_E_OFF; break;
  74   2        }
  75   1      }
  76          
  77          ///////////////////////////////////////////////æŒ‰é”®/////////////////////////////////////////////////////
             -/
  78          
  79          //
  80          //  unsigned char timeBase : è¿›å…¥ä¸€æ¬¡è¯¥å‡½æ•°çš„æ—¶é—´,å•ä½ms
  81          //
  82          enum enum_keyVlaue keyScanf(unsigned char timeBase)
  83          {
  84   1        static unsigned char pressFlag = 0,keyvalue = 0;
  85   1        static unsigned int keyTimeCount = 0;
  86   1        KEY_EN;
  87   1        
  88   1        ioData.key.vlaue = noneKey; //æ¸…é”®å€¼
  89   1        switch(pressFlag)
  90   1        {
  91   2          case 0:
  92   2          {
  93   3            if(KEY_PRESS)
  94   3            {
  95   4              ++keyTimeCount;
  96   4              if((keyTimeCount*timeBase) >= 10)
  97   4              {
  98   5                keyTimeCount = 0;
  99   5                pressFlag = 1;
 100   5                //è®°å½•é”®å€¼
 101   5                if(KEY_PRESS1) keyvalue = 1;
 102   5                else if(KEY_PRESS2) keyvalue = 2;
 103   5                else if(KEY_PRESS1 && KEY_PRESS2) keyvalue = 3;
 104   5              }
 105   4            }
 106   3            else keyTimeCount = 0;
 107   3          }break;
 108   2          case 1:
 109   2          {
 110   3            //åˆ¤æ–­æ˜¯å¦å±äºé•¿æŒ‰
 111   3            ++keyTimeCount;
 112   3            ioData.key.pressTime_100ms = keyTimeCount*timeBase/100;
 113   3            if(ioData.key.pressTime_100ms >= 10)  //1s
 114   3            {
C51 COMPILER V9.60.0.0   IO                                                                12/23/2019 14:27:43 PAGE 3   

 115   4              pressFlag = 2;
 116   4              keyTimeCount = 0;
 117   4              ioData.key.modeLock = noneKey;
 118   4              ioData.key.pressTime_100ms = 0;
 119   4              //æ ¹æ®å½“å‰æŒ‰ä¸‹çš„é”®è¿”å›é”®å€¼
 120   4              if(KEY_PRESS1 && KEY_PRESS2) ioData.key.vlaue = noneKey;
 121   4              else if(KEY_PRESS2) ioData.key.vlaue = shortlongKey2;
 122   4              else if(KEY_PRESS1) ioData.key.vlaue = shortlongKey1;
 123   4            }
 124   3      
 125   3            //ç­‰å¾…çŸ­æŒ‰æŠ¬èµ·
 126   3            if(KEY_NOPRESS)
 127   3            {
 128   4              pressFlag = 0;
 129   4              keyTimeCount = 0;
 130   4              ioData.key.pressTime_100ms = 0;
 131   4              ioData.key.modeLock = noneKey;
 132   4              //æ ¹æ®ä¹‹å‰è®°å½•çš„é”®å€¼è¿”å›
 133   4              if(keyvalue == 1) ioData.key.vlaue = shortKey1;
 134   4              else if(keyvalue == 2) ioData.key.vlaue = shortKey2;
 135   4              else if(keyvalue == 3) ioData.key.vlaue = noneKey;
 136   4            }
 137   3          }break;
 138   2          case 2:
 139   2          { 
 140   3            if(ioData.key.modeLock == noneKey)  //æœªè¢«é”å®š
 141   3            {
 142   4              if(ioData.key.pressTime_100ms < 20) //3s,å› ä¸ºè¿˜æœ‰ä¸Šä¸€æ­¥éª¤ä¸­çš„1s
 143   4              {
 144   5                ++keyTimeCount;
 145   5                ioData.key.pressTime_100ms = keyTimeCount*timeBase/100;
 146   5              }
 147   4              else
 148   4              {
 149   5                pressFlag = 3;
 150   5                //æ ¹æ®å½“å‰æŒ‰ä¸‹çš„é”®è¿”å›é”®å€¼
 151   5                if(KEY_PRESS1 && KEY_PRESS2) ioData.key.vlaue = longDoubleKey;
 152   5                else if(KEY_PRESS2) ioData.key.vlaue = longKey2;
 153   5                else if(KEY_PRESS1) ioData.key.vlaue = longKey1;
 154   5              }
 155   4            }
 156   3            else if(ioData.key.modeLock == shortlongKey1 || ioData.key.modeLock == shortlongKey1)
 157   3            {
 158   4              ++ioData.key.timeCount;
 159   4              ioData.key.pressTime_100ms = ioData.key.timeCount*timeBase/100;
 160   4              if(ioData.key.pressTime_100ms >= 10) ioData.key.timeCount = 0;  //è¯¥å¥é˜²æ­¢ä¸Šæº¢ï¼Œå®é™…ä¸Šå‡ ä¹ä
             -¸å¯èƒ½å‡ºç°ï¼Œä½†ä¸ºäº†é˜²æ­¢ç¨‹åºä¸­æœªåŠæ—¶æ¸…0
 161   4      
 162   4              if(KEY_PRESS2) ioData.key.vlaue = shortlongKey2;
 163   4              else if(KEY_PRESS1) ioData.key.vlaue = shortlongKey1;
 164   4            }
 165   3            
 166   3            //ç­‰å¾…é•¿æŒ‰æŠ¬èµ·
 167   3            if(KEY_NOPRESS)
 168   3            {
 169   4              pressFlag = 0;
 170   4              keyTimeCount = 0;
 171   4              ioData.key.timeCount = 0;
 172   4              ioData.key.pressTime_100ms = 0;
 173   4              ioData.key.modeLock = noneKey;
 174   4            }
 175   3          }break;
C51 COMPILER V9.60.0.0   IO                                                                12/23/2019 14:27:43 PAGE 4   

 176   2          case 3:
 177   2          {
 178   3            //ç­‰å¾…é•¿æŒ‰æŠ¬èµ·
 179   3            if(KEY_NOPRESS)
 180   3            {
 181   4              pressFlag = 0;
 182   4              keyTimeCount = 0;
 183   4              ioData.key.timeCount = 0;
 184   4              ioData.key.pressTime_100ms = 0;
 185   4              ioData.key.modeLock = noneKey;
 186   4            }
 187   3          }break;
 188   2        }
 189   1        KEY_DISEN;
 190   1        return noneKey;
 191   1      }
 192          
 193          ///////////////////////////////////////////////èœ‚é¸£å™¨//////////////////////////////////////////////////
             -////
 194          
 195          //
 196          //å¯ä»¥ç”¨äºå‘¨æœŸæ€§çš„èœ‚é¸£
 197          //
 198          void Beep(void)
 199          {
 200   1        static unsigned int count = 0;
 201   1      
 202   1        if(++count < 100) //0-99mså“
 203   1        {
 204   2          BEEP_ON;
 205   2        }
 206   1        else if(count < 800)  //100-799msä¸å“
 207   1        {
 208   2          BEEP_OFF;
 209   2        }
 210   1        else  //800msæ—¶é‡ç½®è®¡æ•°
 211   1        {
 212   2          count = 0;
 213   2        }
 214   1      }
 215          
 216          //
 217          //å¯ä»¥ç”¨äºæŒ‰é”®éŸ³ï¼Œåœ¨æŒ‰é”®è§¦å‘æ—¶ç½®ä¸ºæ ‡å¿—ä½ï¼Œèœ‚é¸£å™¨å°±å¼€å§‹å·¥ä½œï¼Œå·¥ä½œæ—¶é—´è¿‡å
             -è‡ªåŠ¨æ¸…æ ‡å¿—ä½
 218          //unsigned char* bool : èœ‚é¸£æ ‡å¿—ä½
 219          //
 220          void keyBeep(unsigned char* bool)
 221          {
 222   1        static unsigned int count = 0;
 223   1      
 224   1        if(*bool)
 225   1        {
 226   2          if(++count < 50)  //0-49mså“
 227   2          {
 228   3            BEEP_ON;
 229   3          }
 230   2          else
 231   2          {
 232   3            *bool = 0;
 233   3            BEEP_OFF;
 234   3            count = 0;
 235   3          }
C51 COMPILER V9.60.0.0   IO                                                                12/23/2019 14:27:43 PAGE 5   

 236   2        }
 237   1      }
 238          
 239          ///////////////////////////////////////////////ADC//////////////////////////////////////////////////////
 240          #define RT_TABLE      m_3950K_10K_Rt
 241          #define RT_TABLE_SIZE   101
 242          
 243          const unsigned int m_3950K_10K_Rt[RT_TABLE_SIZE] = 
 244          {
 245            32116,
 246            30570,
 247            29105,
 248            27716,
 249            26399,
 250            25150,
 251            23519,
 252            22427,
 253            21391,
 254            20407,
 255            19452,
 256            18584,
 257            17741,
 258            16940,
 259            16178,
 260            15455,
 261            14766,
 262            14112,
 263            13490,
 264            12898,
 265            12335,
 266            11799,
 267            11288,
 268            10803,
 269            10340,
 270            9900, //25ï¿½ï¿½
 271            9472,
 272            9064,
 273            8676,
 274            8307,
 275            7955,
 276            7619,
 277            7300,
 278            6995,
 279            6705,
 280            6428,
 281            6163,
 282            5911,
 283            5671,
 284            5441,
 285            5222,
 286            5013,
 287            4897,
 288            4704,
 289            4521,
 290            4345,
 291            4177,
 292            4016,
 293            3863,
 294            3716,
 295            3588,
 296            3440,
 297            3311,
C51 COMPILER V9.60.0.0   IO                                                                12/23/2019 14:27:43 PAGE 6   

 298            3188,
 299            3096,
 300            3956,
 301            2848,
 302            2744,
 303            2644,
 304            2548,
 305            2457,
 306            2369,
 307            2284,
 308            2204,
 309            2126,
 310            2051,
 311            1980,
 312            1911,
 313            1845,
 314            1782,
 315            1721,
 316            1663,
 317            1606,
 318            1552,
 319            1500,
 320            1450,
 321            1402,
 322            1356,
 323            1312,
 324            1269,
 325            1228,
 326            1188,
 327            1150,
 328            1113,
 329            1078,
 330            1044, 
 331            1011,
 332            979,
 333            948,
 334            919,
 335            891,
 336            863,
 337            837,
 338            811,
 339            787,
 340            763,
 341            740,
 342            718,
 343            697,
 344            676,
 345            657
 346          };
 347          
 348          /*
 349          åŠŸèƒ½ï¼šè½¬æ¢è·å–æ¸©åº¦å€¼
 350          å‚æ•°ï¼š
 351            ainï¼šé‡‡é›†ADCå€¼ï¼Œ12ä½ADC
 352          è¿”å›ï¼šæ¸©åº¦å€¼ï¼Œå•ä½0.1â„ƒ
 353          */
 354          uint16_t convert_temp(uint16_t ain)
 355          {
 356   1        uint32_t Rt;
 357   1        uint32_t Rtdt;
 358   1        uint32_t temp;
 359   1        uint8_t i;
C51 COMPILER V9.60.0.0   IO                                                                12/23/2019 14:27:43 PAGE 7   

 360   1        
 361   1        temp = (uint32_t)ain;
 362   1        if (temp < 50)
 363   1        {
 364   2          // å¦‚æœç«¯å£çŸ­è·¯ï¼Œç›´æ¥è¿”å›0åº¦
 365   2          return 0;
 366   2        }
 367   1        Rt = temp * 10000L / ( 4096L - temp );      // è®¡ç®—çƒ­æ•ç”µé˜»ç”µé˜»å€¼
 368   1      
 369   1        if ( Rt > RT_TABLE[0] )             // æ¸©åº¦ä½äº0Â°
 370   1        {
 371   2          return 0;
 372   2        }
 373   1        
 374   1        if ( Rt <= RT_TABLE[RT_TABLE_SIZE-1] )      // æ¸©åº¦å¤§äºç­‰äº100åº¦
 375   1        {
 376   2          return 999;
 377   2        }
 378   1        
 379   1        for(i=0; i<(RT_TABLE_SIZE-1); i++)
 380   1        {
 381   2          // åˆ¤æ–­åœ¨å“ªä¸ªä¸¤ä¸ªæ¸©åº¦å€¼èŒƒå›´å†…
 382   2          if ( ( Rt > RT_TABLE[i+1] ) && ( Rt <= RT_TABLE[i] ) )
 383   2          {
 384   3            // è®¡ç®—1åº¦å†…çš„æ’å€¼
 385   3            temp = RT_TABLE[i] - RT_TABLE[i+1];
 386   3            Rtdt = RT_TABLE[i] - Rt;
 387   3            temp = Rtdt * 10 / temp;
 388   3            temp += i * 10;
 389   3            break;
 390   3          }
 391   2        }
 392   1        
 393   1        return (unsigned int)temp;
 394   1      }
 395          void initAdc(void)
 396          {
 397   1        P17_Input_Mode;
 398   1        set_P17DIDS;  //å…³é—­ADCä¿¡é“æ•°å­—è¾“å…¥åŠŸèƒ½
 399   1        clr_ADCHS0;clr_ADCHS1;clr_ADCHS2;clr_ADCHS3;  //é€šé“é€‰æ‹©0000-å³é€šé“AIN0
 400   1        clr_ADCEX;  //è½¯ä»¶è§¦å‘è½¬æ¢
 401   1        set_ADCEN;  //æ‰“å¼€ADCè½¬æ¢ç”µè·¯
 402   1      }
 403          
 404          unsigned int getAdc(void)
 405          {
 406   1        unsigned int adcValue = 0;
 407   1        clr_ADCF; //æ¸…è½¬æ¢ç»“æŸæ ‡å¿—
 408   1        set_ADCS; //å¼€å§‹è½¬æ¢
 409   1        while(!ADCF); //ç­‰å¾…è½¬æ¢å®Œæˆ
 410   1        adcValue = (ADCRH<<4) | (ADCRL&0x0f);
 411   1        return convert_temp(adcValue);
 412   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3033    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    215      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   IO                                                                12/23/2019 14:27:43 PAGE 8   

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
